import threading
import queue
import time
import random

NUM_CUSTOMERS = 12
RANDOM_SEED   = 42
random.seed(RANDOM_SEED)

STAGE_DURATIONS = {
    "Consultation" : 0.10,
    "Washing"      : 0.25,
    "Cutting"      : 0.75,
    "Styling"      : 0.10,
    "Checkout"     : 0.05,
}

barber_chair_lock = threading.Lock()
done_count        = 0
done_lock         = threading.Lock()
print_lock        = threading.Lock()

def log(msg):
    with print_lock:
        print(msg)

def do_stage(stage_name):
    base   = STAGE_DURATIONS[stage_name]
    jitter = random.uniform(0.85, 1.15)
    time.sleep(base * jitter)

SENTINEL = None

#Sequential
def sequential_barbershop():
    print("\n" + "="*55)
    print("  SEQUENTIAL MODE")
    print("="*55)
    start = time.perf_counter()
    for cid in range(1, NUM_CUSTOMERS + 1):
        log(f"  [Barber] Customer {cid:02d} - starting...")
        for stage in STAGE_DURATIONS:
            do_stage(stage)
        log(f"  [Barber] Customer {cid:02d} - done.")
    elapsed = time.perf_counter() - start
    print(f"\n  Sequential time: {elapsed:.4f} s")
    return elapsed

#Workers
def worker_1(in_q, out_q):
    while True:
        customer = in_q.get()
        if customer is SENTINEL:
            out_q.put(SENTINEL)
            break
        cid = customer["id"]
        log(f"  [W1 - Consultation] Customer {cid:02d} - consulting...")
        do_stage("Consultation")
        log(f"  [W1 - Consultation] Customer {cid:02d} - done.")
        out_q.put(customer)

def worker_2(in_q, out_q):
    while True:
        customer = in_q.get()
        if customer is SENTINEL:
            out_q.put(SENTINEL)
            break
        cid = customer["id"]
        log(f"  [W2 - Washing]      Customer {cid:02d} - washing...")
        do_stage("Washing")
        log(f"  [W2 - Washing]      Customer {cid:02d} - done.")
        out_q.put(customer)

def worker_3(in_q, out_q):
    while True:
        customer = in_q.get()
        if customer is SENTINEL:
            out_q.put(SENTINEL)
            break
        cid = customer["id"]
        log(f"  [W3 - Cutting]      Customer {cid:02d} - waiting for chair...")
        barber_chair_lock.acquire()
        log(f"  [W3 - Cutting]      Customer {cid:02d} - cutting... [LOCKED]")
        do_stage("Cutting")
        barber_chair_lock.release()
        log(f"  [W3 - Cutting]      Customer {cid:02d} - done. [UNLOCKED]")
        out_q.put(customer)

def worker_4(in_q):
    global done_count
    while True:
        customer = in_q.get()
        if customer is SENTINEL:
            break
        cid = customer["id"]
        log(f"  [W4 - Styling]      Customer {cid:02d} - styling & checkout...")
        do_stage("Styling")
        do_stage("Checkout")
        with done_lock:
            done_count += 1
            log(f"  [W4 - Styling]      Customer {cid:02d} - COMPLETE [{done_count}/{NUM_CUSTOMERS}]")

#Parallel
def parallel_barbershop():
    global done_count
    done_count = 0

    print("\n" + "="*55)
    print("  PARALLEL MODE â€” 4-Stage Pipeline (Task Parallelism)")
    print("="*55)

    input_q = queue.Queue()
    q1      = queue.Queue()
    q2      = queue.Queue()
    q3      = queue.Queue()

    threads = [
        threading.Thread(target=worker_1, args=(input_q, q1)),
        threading.Thread(target=worker_2, args=(q1, q2)),
        threading.Thread(target=worker_3, args=(q2, q3)),
        threading.Thread(target=worker_4, args=(q3,)),
    ]

    start = time.perf_counter()

    for t in threads:
        t.start()

    for cid in range(1, NUM_CUSTOMERS + 1):
        input_q.put({"id": cid})
    input_q.put(SENTINEL)

    for t in threads:
        t.join()

    elapsed = time.perf_counter() - start
    print(f"\n  Parallel time: {elapsed:.4f} s")
    return elapsed

